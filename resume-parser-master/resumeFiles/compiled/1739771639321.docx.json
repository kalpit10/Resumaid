{"name":"T I","summary":"(\nfunction() {\napi.updateWallet()\n}\n)\n}\n}\nHere, we can see that after the order is created, we have another callback function inside it which will be called after the order is created. After the payment is done, another cb function is called which is show order summary. So here, if we notice we are stuck in a callback hell, where there is one callback inside another callback and so on….\nThis is also called Pyramid Of Doom.\nAnother problem we face while using callbacks is Inversion of Control.\nLosing the control of code while using callbacks. We have given to control of a function to another function and we don't know if the first function will call the cb function correctly.\nPROMISES:\nFrom the last example,\nconst cart = [\"shoes\", \"pants\", \"kurta\"];\napi.createOrder (cart, function () {\napi.proceedToPayment(orderId);\n});\nconst promise = createOrder(cart);\nPromise is an empty object with some data value. When the last line executes, it will return us a promise. Since, the createOrder is an async task (meaning, we don't know how much time it will take to execute). So, it will fill this promise object automatically after an async time.\nWe will attach a callback function to this promise object.\npromise.then( function () {\napi.proceedToPayment(orderId);\n});\nOnce we have data filled in promise object, this function will automatically be called. This type of practice is much much better than previous callback hell.\nHow?\nIn callback hell, we were passing a cb function and blindly trusting it will execute, which is risky. But in this case, we are attaching not passing a function to a promise object. Here, when the data is returned to a promise, then the function will be called. That means, this is in our control. Here the guarantee also is, when the data inside promise, it will 100% call the function and only once.\nFor Example:\nconst API = https://jjknfjewfnj.com;\nconst user = fetch(API);\nconsole.log(API);\nHere, fetch returns a PROMISE and is stored in the user variable. In chrome, when we try this out, if we run it now.. it will show us pending state. So promise has 3 states, pending, fulfilled and rejected. In chrome, as of we are talking now (Year 2024). The chrome browser will log it as pending, but if we expand it , it will show us fulfilled. Just another Chrome browser issue.\nPromises are immutable (meaning, it will not change and we can blindly pass that data or play with it).\nWhat is a Promise?\nPromise is a placeholder, which will be filled later with a value from an async operation.\nOR\nPromise is an object representing the eventual completion or failure of an async operation. (Use this if possible)\nPROMISE CHAINING:\ncreateOrder(cart).then(function (orderId) {\nreturn proceedtoPayment(orderId)) // Remember to return, so that the value passes on to next chain.\n}.then (function (paymentInfo) {\nreturn showOrderSummary(paymentInfo))\n}\nHow to create a Promise?\nSame example of cart…\nHere, we write the logic of creating an order. We create a promise with new Promise(resolve, reject) keyword. And now we have written of the cart validation. If there is an error, we use reject keyword otherwise we use resolve keyword. So, when we call the createOrder API, a promise is created.\nHandling errors with catch statements.\nThis is promise chaining. Remember to return it so that the values can be passed down the chain.\nWhat if the cart was not validated and still, we wanted to proceed to payment?\nHere, we just move the catch statement above in the chain. Now, the catch statement has the responsibility to check only which is on top of it. It will not check what is below catch statement.\nPROMISE APIs:\nTERMS:\n1. Promise.all()\nIf we had to make parallel API calls\nSuppose if we had 10 user id's and we want an API call for user info and when we want to make the API call and get the result of 10 different users.\nTakes an array of promises\nIt returns an array with the result of all of the promises.\nIt will wait for all of them to finish before returning the array of output.\nHere, it will return the output after 3 seconds if every promise is successful.\nWhy 3 seconds? As the total time here is 3 seconds and everything is running in parallel. So it will wait until everything is finished.\nNow, what if one of them gets rejected?\nAs soon as one of them gets rejected, Promise.all() will throw an error with the same error of the one which got rejected.\nSo that means, here in the above example, every promise is running parallelly. So, after 1 second it will throw and error and not wait for others to finish.\nWhat about p1 and p3? Will they get cancelled? No, they will not get cancelled but the end result of promise.all() will be a reject as one of them got rejected.\nCODE:\nAfter 1 second it failed.\nNow, what if we wanted the successful promises even when one of them or few of them gets rejected. How do we do that?\nWe have,\n2. Promise.allSettled() for it. Even when one of them gets rejected, it will wait for all promises to settle. That means, it will wait for 3 seconds, it will return the array of output.\nIt will display status of all 3, if gets fulfilled it will show that as well as the error of rejection.\nCODE:\nWaited for all the promises to settle then returned the result.\n3. Promise.race()\nTaking the above example, if p1 takes 3s, p2 takes 5s, and p3 takes 2s. It will return the value of the one that gets finished first. That means, val3 will get returned from p3 after 2 seconds.\nWhat if the first settled promise was rejected?\nError will be thrown.\nIt's just like a race. It will return the results(resolved or rejected0 according to the timeline of promises. Only the first settled (means not in a pending state) promise (Either resolved or rejected).\nReturns a single promise.\nCODE:\nReturned P2's success.\n4. Promise.any()\nHere, it will wait for first settled success.\nIf the first gets rejected, it will wait for the success and not return anything. Returns a single promise. Seeking first success\nWhat if everything fails?\nReturned result will be an aggregate error. It will be an array of all the errors.\nCODE:\nReturned first settled success [p1] after 3 seconds even when p2 got an error after 2 seconds.\nAggregate error came when everything failed.\nCheck the code here. We said that we will get an array of errors but we did not at first. Check the catch statement. That's how you print the array of errors.\nWe had to do a console.log()\nASYNC/AWAIT :\nWhat is async?\nIt is a keyword that is used before a function to make it asynchronous.\nHow is it different from a normal function?\nAsync func. always return a promise\nIt can return directly a promise. Or, if we find out that it is returning, for example, a string. It will wrap that string inside a promise and return it.\nIt returned a promise.\nHere, when the promise is returned from the function, it is stored inside a value dataPromise. Now , when we do .then(), the result will log the actual value, which is Namaste.\nHere, in the code we created another promise. And inside the async function, we called \"p\".\nWhat will happen here? Will it wrap a promise into another promise and return it? No, if the return value already a promise, it will be returned as it is.\nAsync and await combo is used to handle promises.\nHow did we used to handle promises before async/await?\nWe just called a (res) and console.log() the value.\nHere, we will use a keyword await to handle promises. The variable \"val\" will contain the value of the resolved promise.\nSame result.\nWhat is await?\nAwait is a keyword that can be used only inside an async function.\nWhat is the difference between async/await and normal promise handling?\nIn the code, when we call the getData() function, what do you think is going to happen? What will be the output? Will console.log() be printed first or the resolved promise value?\nThe console.log() will be printed first. JSEngine will not wait for promise to be resolved and move on to the next line.\nOutput:\nNamaste Javascript\nPromise resolved value!!\nThe promise resolved value would be printed after 10 seconds. If we changed the setTimeout to run after 0ms. Both will be printed at the same time.\nThis is how the promises were handled before.\nNow with async/await…\nHere, the code will wait on line no.20 till the promise resolves and then print both the values together. JSEngine will wait for promise to get resolved. Will only go to next line once the promise is resolved.\nNOTE: If we had a console.log() above the await keyword. That would have been executed first then, the engine would wait for promise to get resolved and then move on to the next line.\nIf we had await keyword 2 times. What will happen here? Will the program will wait for two times? Or will it run parallelly? It will run parallelly and print both of them on the same time. Will not wait for two times.\nNow what about this code:\nconst p1 = new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve('Hello');\n}, 10000)\n})\nconst p2 = new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve('Hello Again');\n}, 5000)\n})\nasync function handlePromise() {\nconsole.log(\"Will I get executed first?\");\nconst val = await p1;\nconsole.log(\"Namaste!\");\nconsole.log(val);\nconst val2 = await p2;\nconsole.log(\"Namaste!\");\nconsole.log(val2);\n}\nhandlePromise();\nWhat will happen here?\nAfter 10 seconds, all of it will be printed. The promise which had 5 seconds got resolved but still waited for 10 seconds.\nNow what about if we reversed the timeouts. If p1 had 5 seconds and p2 had 10 seconds. What will happen now? After 5 seconds the p1 resolved value will be printed and then the next promise will be resolved and printed. This is confusing and these are few of the interview questions that get asked around this. And ofcourse the console.log value above await keyword will be printed first before all of this.\nHow will this work behind the scenes?\nThe call stack starts empty.\nWhen the function handlePromise() is called, it enters the call stack.\nSince JavaScript is single-threaded, it executes the code line by line.\nThe first console.log (above the await keyword) is printed immediately.\nThe next line contains await p1:\nEncountering the await keyword suspends the execution of handlePromise().\nThe function moves out of the call stack and does not block the page.\nOnce p1 resolves (after 5 seconds):\nhandlePromise() re-enters the call stack.\nExecution resumes from where it was suspended.\nIt logs the values \"Namaste\" and \"Hello\".\nThe next line contains await p2:\nIf p2 is unresolved, the execution is suspended again.\nThe call stack becomes free.\nOnce p2 resolves:\nhandlePromise() re-enters the call stack.\nExecution resumes, logging \"Namaste!\" and \"Hello Again\".\nHow Fetch Works?\nSo fetch is a promise, when this promise is resolved, it gives us a response object. This response object has a body, which as a readable stream. This response body is a readbale stream. If we have to convert this readbale stream to json, we have to use .json(). This json() is again a promise. When this promise is resolved, it gives us the json value.\nHow will we handle errors in async await?\nWe will use try{}catch{} method.\nIn conclusion, ASYNC/AWAIT IS JUST A SYNTACTICAL SUGAR FOR HANDLING PROMISES. BOTH OF THESE METHODS TO HANDLE PROMISES ARE GOOD BUT IT HAS FEW DIFFERENCES WHICH WE STUDIED. IT'S JUST A NEW WAY OF WRITING CODE. HERE WE DON'T HAVE TO DO PROMISE CHAINING WHILE WE USE ASYNC / AWAIT.\nIT'S A PERSONAL CHOICE.\nHoisting\nHere, if we wrote a code:\nvar x = 7;\nfunction getName() {\nconsole.log(\"Namaste JavaScript!\");\n}\ngetName();\nconsole.log(x);\nOutput:\nNamaste Javascript\n7\nThis works fine. But what if we did something like this:\ngetName(); //it will read this function even If we move it above the declaration\nconsole.log(x); // it will give us undefined here\nvar x = 7;\nfunction getName() {\nconsole.log(\"Namaste JavaScript!\");\n}\nOutput:\nNamaste JavaScript\nUndefined\nNow if we removed the initialisation of x and then ran the program, it would have given us an error.\nThis is called Hoisting. So, Hoisting is a phenomenon in JavaScript by which we can access the variables and functions even before we initialised it. We can access it without any error.\nSo, from where did this undefined keyword comes from?\nThis happens because even before the start of the execution of a program, JS skims through the program and it will allocate memory for these variables. So, it will store a special keyword undefined over here.\nWhat happens in case of functions?\nThe whole code is put in. We will get an actual copy of a function.\nThe difference between not defined and undefined.\nundefined is used when a variable is declared but not initialised.\nnot defined occurs when you try to access a variable that hasn't been declared at all.\nIf we created getName as an arrow function:\nThis error will occur because here using arrow function, it will behave like a variable.\nEven if we create a function with this syntax, it will behave just like a variable and during the memory allocation process, it will be allocated undefined.\nNOTE: STUDY MORE ABOUT THIS TOPIC REGARDING VAR, LET, CONST Etc.\nClosures\n\"- Output questions\nLexical Scoping:\nfunction x() {\nvar a = 7;\nfunction y() {\nconsole.log(a);\n}\ny();\n}\nx();\nOutput:\n7\nWhy 7? This is called lexical scoping.\nLexical scoping means that when you write a function inside another function, the inner function can access variables from its own scope, plus variables from its parent's scope. Think of it like a child who has their own toys (local variables) but can also use their parent's stuff (parent scope variables).\nInner functions can look outside their scope to find variables\nOuter functions cannot look inside inner functions\nThis \"scope chain\" always goes from inside to outside, never the other way\nWhat is Closure?\nA closure is formed when a function \"remembers\" and can access variables from its outer scope even after the outer function has finished executing. Think of it like a backpack that a function carries around, containing all the variables it had access to when it was created.\nCode:\nfunction createCounter() {\nlet count = 0; // Private variable\nreturn function() {\ncount++;\nconsole.log(count);\nreturn count;\n}\n}\nconst counter = createCounter();\ncounter(); // 1\ncounter(); // 2\ncounter(); // 3\nconst counter2 = createCounter();\ncounter2(); // 1\ncounter2(); // 2\nLet me explain closures with a simple counter example. A closure is formed when a function retains access to variables from its outer scope even after the outer function has finished executing.\nIn this code:\ncreateCounter creates a variable count and returns a function\nThe returned function has access to count even after createCounter finishes running\nEach time we call counter(), it \"remembers\" and updates the same count variable\nIf we create a new counter (counter2), it gets its own separate count variable\nINTERVIEW QUESTION:\nfunction outer() {\nfor(var i = 1 ; i <= 5; i++) {\nsetTimeout(function () {\nconsole.log(i)\n}, i * 1000);\n}\nconsole.log(\"Namaste Javascript!\");\n}\nouter();\nIf I run this code, the output is going to be 6 (5 times) after a second each. But if I replace var i = 1 to let i = 1. The output runs perfectly , which is 1 2 3 4 5.\nWhy?\nWith var:\nWhat happens:\nvar creates ONE single i that's shared by all setTimeout callbacks\nThe loop finishes running (i becomes 6) before any setTimeout executes\nWhen the timeouts finally run, they all reference the same i, which is now 6\nSo you get: 6, 6, 6, 6, 6\nWith let:\nWhat happens:\nlet creates a NEW i for each loop iteration\nEach setTimeout callback captures its own copy of i\nWhen the timeouts run, each has its own preserved value of i\nSo you get: 1, 2, 3, 4, 5\nNow, what if the interviewer asks to run it through var only, we cannot use let for this. Produce the same output with var.\nAnswer:\nfunction outer() {\nfor(var i = 1 ; i <= 5; i++) {\nfunction close(i) {\nsetTimeout(function () {\nconsole.log(i)\n}, i * 1000);\n}\nclose(i)\n}\nconsole.log(\"Namaste Javascript!\");\n}\nouter();\nHere, using close function, we created a new copy of i, whenever we called setTimeout.\nHere's what's happening:\nEach time the loop runs, it calls close(i) with the current value of i\nThe close function creates a new scope each time it's called\nEach timeout function forms a closure with its own copy of i from its close function's parameters\nSo each timeout \"remembers\" its own unique value of i\nThink of it like this:\nFirst loop: close(1) creates a scope with i = 1\nSecond loop: close(2) creates a scope with i = 2\nAnd so on...\nIt's similar to giving each setTimeout its own private mailbox (scope) with its own number inside, rather than having them all share the same mailbox like in the original var example.\nThis works because:\nFunction parameters create a new scope\nEach call to close() gets its own parameter i\nThe setTimeout closure captures this scoped parameter\nThis is essentially doing manually what let does automatically in the loop!\nPrototypes and Inheritance\n\"- Generally theory questions\nThis Keyword\n\"- Always remember if using this keyword with normal fn. Or arrow fn. can be different\n\"this\" in global space:\nNow, if we do a console.log(this) inside global space. We get an output of a window object.\nWhy the value is window object?\nthis in global space will always have the value of global object, which is window object. In browser, the global object is window.\nThe answer for us here depends on the global object. It can be window or something else. Depends upon where we are running our code.\n\"this\" inside a function:\n// outputs to window object again.\nWhat is the difference? Is it same?\nNo, it is not same, it is different. So when we run the function in a normal javascript environment. It is called as \"unstrict mode\". In this , the value will come out to be window object inside a function.\nBut if we use strict mode in javascript. The output comes out to be undefined.\nWhy this happens?\nIt is because of \"this substitution\". If the value of this is undefined or null. this will be replaced with global object (Non-strict mode).\nSo how to answer a question like: What is the value of this inside a function?\nThe value of this will be undefined if we use strict mode but because of this substitution, we have the value as globalObject in non-strict mode. Inside non-strict mode, we have concept called as this substitution because of which we get globalObject.\nIf we use strict mode, and we call the function as:\nThe output comes out to be a window object now. // window.x();\nIt depends on how the function is called. If we call it like x();// without reference of object. We will get an output as undefined. If we called it with reference to the object // window.x(); We will get output as the window object. (This is all run in strict mode).\nQ. What is the difference between a function and a method in Javascript?\nWhen we create a function inside an object. It is called as method.\nHere, x is a method.\nFor this piece of code. The output of the value of this is:\nThe object itself.\nIf we did this.a(), output // 10\nCall/apply/bind methods: (Watch the video for call/apply/bind)\nCall is basically used for sharing the content of another object.\nHere's what's happening:\nWhen you use student.printName()\nthis points to whatever is before the dot (.)\nSo this refers to student object\nTherefore this.name prints \"John\"\nWhen you use student.printName.call(student2)\ncall method lets you borrow a function and use it with a different object\nIt says \"hey, use this function, but pretend this is student2\"\nSo now this refers to student2\nTherefore this.name prints \"Kalpit\"\nThink of call like borrowing a friend's method:\nstudent2 is borrowing the printName function from student\ncall lets you say \"use this function, but with my data instead\"\nThere's also apply and bind which work similarly:\nCODE:\nstudent.printName.apply(student2); // Same as call\nconst newFn = student.printName.bind(student2); // Creates new function\nnewFn(); // Prints: \"Kalpit\"\nBehaviour of this keyword inside arrow functions:\nArrow functions don't provide their own this binding.\nHere, in this code, the value of this will not be according to the function. It will be according to its \"enclosing lexical environment\". So here, the value is again a window object.\nNow,\nFor this piece of code. What will be the output?\nHere the output will be:\nThe object itself. Why?\nCheck its enclosing lexical environment. The enclosing lexical environment is the function in method x(). That is why, it is printing the object itself.\nIt will behave exactly like this code.\nBehaviour of this keyword inside DOM:\nIn this piece of code, the value of this will be the value of button element itself.\nSo if the question is: What is the value of this inside DOM?\nthis inside DOM elements => reference to HTMLElement.\nFlattening Objects(paymentInfo))\n}\nHow to create a Promise?\nSame example of cart…\nHere, we write the logic of creating an order. We create a promise with new Promise(resolve, reject) keyword. And now we have written of the cart validation. If there is an error, we use reject keyword otherwise we use resolve keyword. So, when we call the createOrder API, a promise is created.\nHandling errors with catch statements.\nThis is promise chaining. Remember to return it so that the values can be passed down the chain.\nWhat if the cart was not validated and still, we wanted to proceed to payment?\nHere, we just move the catch statement above in the chain. Now, the catch statement has the responsibility to check only which is on top of it. It will not check what is below catch statement.\nPROMISE APIs:\nTERMS:\n1. Promise.all()\nIf we had to make parallel API calls\nSuppose if we had 10 user id's and we want an API call for user info and when we want to make the API call and get the result of 10 different users.\nTakes an array of promises\nIt returns an array with the result of all of the promises.\nIt will wait for all of them to finish before returning the array of output.\nHere, it will return the output after 3 seconds if every promise is successful.\nWhy 3 seconds? As the total time here is 3 seconds and everything is running in parallel. So it will wait until everything is finished.\nNow, what if one of them gets rejected?\nAs soon as one of them gets rejected, Promise.all() will throw an error with the same error of the one which got rejected.\nSo that means, here in the above example, every promise is running parallelly. So, after 1 second it will throw and error and not wait for others to finish.\nWhat about p1 and p3? Will they get cancelled? No, they will not get cancelled but the end result of promise.all() will be a reject as one of them got rejected.\nCODE:\nAfter 1 second it failed.\nNow, what if we wanted the successful promises even when one of them or few of them gets rejected. How do we do that?\nWe have,\n2. Promise.allSettled() for it. Even when one of them gets rejected, it will wait for all promises to settle. That means, it will wait for 3 seconds, it will return the array of output.\nIt will display status of all 3, if gets fulfilled it will show that as well as the error of rejection.\nCODE:\nWaited for all the promises to settle then returned the result.\n3. Promise.race()\nTaking the above example, if p1 takes 3s, p2 takes 5s, and p3 takes 2s. It will return the value of the one that gets finished first. That means, val3 will get returned from p3 after 2 seconds.\nWhat if the first settled promise was rejected?\nError will be thrown.\nIt's just like a race. It will return the results(resolved or rejected0 according to the timeline of promises. Only the first settled (means not in a pending state) promise (Either resolved or rejected).\nReturns a single promise.\nCODE:\nReturned P2's success.\n4. Promise.any()\nHere, it will wait for first settled success.\nIf the first gets rejected, it will wait for the success and not return anything. Returns a single promise. Seeking first success\nWhat if everything fails?\nReturned result will be an aggregate error. It will be an array of all the errors.\nCODE:\nReturned first settled success [p1] after 3 seconds even when p2 got an error after 2 seconds.\nAggregate error came when everything failed.\nCheck the code here. We said that we will get an array of errors but we did not at first. Check the catch statement. That's how you print the array of errors.\nWe had to do a console.log()\nASYNC/AWAIT :\nWhat is async?\nIt is a keyword that is used before a function to make it asynchronous.\nHow is it different from a normal function?\nAsync func. always return a promise\nIt can return directly a promise. Or, if we find out that it is returning, for example, a string. It will wrap that string inside a promise and return it.\nIt returned a promise.\nHere, when the promise is returned from the function, it is stored inside a value dataPromise. Now , when we do .then(), the result will log the actual value, which is Namaste.\nHere, in the code we created another promise. And inside the async function, we called \"p\".\nWhat will happen here? Will it wrap a promise into another promise and return it? No, if the return value already a promise, it will be returned as it is.\nAsync and await combo is used to handle promises.\nHow did we used to handle promises before async/await?\nWe just called a (res) and console.log() the value.\nHere, we will use a keyword await to handle promises. The variable \"val\" will contain the value of the resolved promise.\nSame result.\nWhat is await?\nAwait is a keyword that can be used only inside an async function.\nWhat is the difference between async/await and normal promise handling?\nIn the code, when we call the getData() function, what do you think is going to happen? What will be the output? Will console.log() be printed first or the resolved promise value?\nThe console.log() will be printed first. JSEngine will not wait for promise to be resolved and move on to the next line.\nOutput:\nNamaste Javascript\nPromise resolved value!!\nThe promise resolved value would be printed after 10 seconds. If we changed the setTimeout to run after 0ms. Both will be printed at the same time.\nThis is how the promises were handled before.\nNow with async/await…\nHere, the code will wait on line no.20 till the promise resolves and then print both the values together. JSEngine will wait for promise to get resolved. Will only go to next line once the promise is resolved.\nNOTE: If we had a console.log() above the await keyword. That would have been executed first then, the engine would wait for promise to get resolved and then move on to the next line.\nIf we had await keyword 2 times. What will happen here? Will the program will wait for two times? Or will it run parallelly? It will run parallelly and print both of them on the same time. Will not wait for two times.\nNow what about this code:\nconst p1 = new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve('Hello');\n}, 10000)\n})\nconst p2 = new Promise((resolve, reject) => {\nsetTimeout(() => {\nresolve('Hello Again');\n}, 5000)\n})\nasync function handlePromise() {\nconsole.log(\"Will I get executed first?\");\nconst val = await p1;\nconsole.log(\"Namaste!\");\nconsole.log(val);\nconst val2 = await p2;\nconsole.log(\"Namaste!\");\nconsole.log(val2);\n}\nhandlePromise();\nWhat will happen here?\nAfter 10 seconds, all of it will be printed. The promise which had 5 seconds got resolved but still waited for 10 seconds.\nNow what about if we reversed the timeouts. If p1 had 5 seconds and p2 had 10 seconds. What will happen now? After 5 seconds the p1 resolved value will be printed and then the next promise will be resolved and printed. This is confusing and these are few of the interview questions that get asked around this. And ofcourse the console.log value above await keyword will be printed first before all of this.\nHow will this work behind the scenes?\nThe call stack starts empty.\nWhen the function handlePromise() is called, it enters the call stack.\nSince JavaScript is single-threaded, it executes the code line by line.\nThe first console.log (above the await keyword) is printed immediately.\nThe next line contains await p1:\nEncountering the await keyword suspends the execution of handlePromise().\nThe function moves out of the call stack and does not block the page.\nOnce p1 resolves (after 5 seconds):\nhandlePromise() re-enters the call stack.\nExecution resumes from where it was suspended.\nIt logs the values \"Namaste\" and \"Hello\".\nThe next line contains await p2:\nIf p2 is unresolved, the execution is suspended again.\nThe call stack becomes free.\nOnce p2 resolves:\nhandlePromise() re-enters the call stack.\nExecution resumes, logging \"Namaste!\" and \"Hello Again\".\nHow Fetch Works?\nSo fetch is a promise, when this promise is resolved, it gives us a response object. This response object has a body, which as a readable stream. This response body is a readbale stream. If we have to convert this readbale stream to json, we have to use .json(). This json() is again a promise. When this promise is resolved, it gives us the json value.\nHow will we handle errors in async await?\nWe will use try{}catch{} method.\nIn conclusion, ASYNC/AWAIT IS JUST A SYNTACTICAL SUGAR FOR HANDLING PROMISES. BOTH OF THESE METHODS TO HANDLE PROMISES ARE GOOD BUT IT HAS FEW DIFFERENCES WHICH WE STUDIED. IT'S JUST A NEW WAY OF WRITING CODE. HERE WE DON'T HAVE TO DO PROMISE CHAINING WHILE WE USE ASYNC / AWAIT.\nIT'S A PERSONAL CHOICE.\nHoisting\nHere, if we wrote a code:\nvar x = 7;\nfunction getName() {\nconsole.log(\"Namaste JavaScript!\");\n}\ngetName();\nconsole.log(x);\nOutput:\nNamaste Javascript\n7\nThis works fine. But what if we did something like this:\ngetName(); //it will read this function even If we move it above the declaration\nconsole.log(x); // it will give us undefined here\nvar x = 7;\nfunction getName() {\nconsole.log(\"Namaste JavaScript!\");\n}\nOutput:\nNamaste JavaScript\nUndefined\nNow if we removed the initialisation of x and then ran the program, it would have given us an error.\nThis is called Hoisting. So, Hoisting is a phenomenon in JavaScript by which we can access the variables and functions even before we initialised it. We can access it without any error.\nSo, from where did this undefined keyword comes from?\nThis happens because even before the start of the execution of a program, JS skims through the program and it will allocate memory for these variables. So, it will store a special keyword undefined over here.\nWhat happens in case of functions?\nThe whole code is put in. We will get an actual copy of a function.\nThe difference between not defined and undefined.\nundefined is used when a variable is declared but not initialised.\nnot defined occurs when you try to access a variable that hasn't been declared at all.\nIf we created getName as an arrow function:\nThis error will occur because here using arrow function, it will behave like a variable.\nEven if we create a function with this syntax, it will behave just like a variable and during the memory allocation process, it will be allocated undefined.\nNOTE: STUDY MORE ABOUT THIS TOPIC REGARDING VAR, LET, CONST Etc.\nClosures\n\"- Output questions\nLexical Scoping:\nfunction x() {\nvar a = 7;\nfunction y() {\nconsole.log(a);\n}\ny();\n}\nx();\nOutput:\n7\nWhy 7? This is called lexical scoping.\nLexical scoping means that when you write a function inside another function, the inner function can access variables from its own scope, plus variables from its parent's scope. Think of it like a child who has their own toys (local variables) but can also use their parent's stuff (parent scope variables).\nInner functions can look outside their scope to find variables\nOuter functions cannot look inside inner functions\nThis \"scope chain\" always goes from inside to outside, never the other way\nWhat is Closure?\nA closure is formed when a function \"remembers\" and can access variables from its outer scope even after the outer function has finished executing. Think of it like a backpack that a function carries around, containing all the variables it had access to when it was created.\nCode:\nfunction createCounter() {\nlet count = 0; // Private variable\nreturn function() {\ncount++;\nconsole.log(count);\nreturn count;\n}\n}\nconst counter = createCounter();\ncounter(); // 1\ncounter(); // 2\ncounter(); // 3\nconst counter2 = createCounter();\ncounter2(); // 1\ncounter2(); // 2\nLet me explain closures with a simple counter example. A closure is formed when a function retains access to variables from its outer scope even after the outer function has finished executing.\nIn this code:\ncreateCounter creates a variable count and returns a function\nThe returned function has access to count even after createCounter finishes running\nEach time we call counter(), it \"remembers\" and updates the same count variable\nIf we create a new counter (counter2), it gets its own separate count variable\nINTERVIEW QUESTION:\nfunction outer() {\nfor(var i = 1 ; i <= 5; i++) {\nsetTimeout(function () {\nconsole.log(i)\n}, i * 1000);\n}\nconsole.log(\"Namaste Javascript!\");\n}\nouter();\nIf I run this code, the output is going to be 6 (5 times) after a second each. But if I replace var i = 1 to let i = 1. The output runs perfectly , which is 1 2 3 4 5.\nWhy?\nWith var:\nWhat happens:\nvar creates ONE single i that's shared by all setTimeout callbacks\nThe loop finishes running (i becomes 6) before any setTimeout executes\nWhen the timeouts finally run, they all reference the same i, which is now 6\nSo you get: 6, 6, 6, 6, 6\nWith let:\nWhat happens:\nlet creates a NEW i for each loop iteration\nEach setTimeout callback captures its own copy of i\nWhen the timeouts run, each has its own preserved value of i\nSo you get: 1, 2, 3, 4, 5\nNow, what if the interviewer asks to run it through var only, we cannot use let for this. Produce the same output with var.\nAnswer:\nfunction outer() {\nfor(var i = 1 ; i <= 5; i++) {\nfunction close(i) {\nsetTimeout(function () {\nconsole.log(i)\n}, i * 1000);\n}\nclose(i)\n}\nconsole.log(\"Namaste Javascript!\");\n}\nouter();\nHere, using close function, we created a new copy of i, whenever we called setTimeout.\nHere's what's happening:\nEach time the loop runs, it calls close(i) with the current value of i\nThe close function creates a new scope each time it's called\nEach timeout function forms a closure with its own copy of i from its close function's parameters\nSo each timeout \"remembers\" its own unique value of i\nThink of it like this:\nFirst loop: close(1) creates a scope with i = 1\nSecond loop: close(2) creates a scope with i = 2\nAnd so on...\nIt's similar to giving each setTimeout its own private mailbox (scope) with its own number inside, rather than having them all share the same mailbox like in the original var example.\nThis works because:\nFunction parameters create a new scope\nEach call to close() gets its own parameter i\nThe setTimeout closure captures this scoped parameter\nThis is essentially doing manually what let does automatically in the loop!\nPrototypes and Inheritance\n\"- Generally theory questions\nThis Keyword\n\"- Always remember if using this keyword with normal fn. Or arrow fn. can be different\n\"this\" in global space:\nNow, if we do a console.log(this) inside global space. We get an output of a window object.\nWhy the value is window object?\nthis in global space will always have the value of global object, which is window object. In browser, the global object is window.\nThe answer for us here depends on the global object. It can be window or something else. Depends upon where we are running our code.\n\"this\" inside a function:\n// outputs to window object again.\nWhat is the difference? Is it same?\nNo, it is not same, it is different. So when we run the function in a normal javascript environment. It is called as \"unstrict mode\". In this , the value will come out to be window object inside a function.\nBut if we use strict mode in javascript. The output comes out to be undefined.\nWhy this happens?\nIt is because of \"this substitution\". If the value of this is undefined or null. this will be replaced with global object (Non-strict mode).\nSo how to answer a question like: What is the value of this inside a function?\nThe value of this will be undefined if we use strict mode but because of this substitution, we have the value as globalObject in non-strict mode. Inside non-strict mode, we have concept called as this substitution because of which we get globalObject.\nIf we use strict mode, and we call the function as:\nThe output comes out to be a window object now. // window.x();\nIt depends on how the function is called. If we call it like x();// without reference of object. We will get an output as undefined. If we called it with reference to the object // window.x(); We will get output as the window object. (This is all run in strict mode).\nQ. What is the difference between a function and a method in Javascript?\nWhen we create a function inside an object. It is called as method.\nHere, x is a method.\nFor this piece of code. The output of the value of this is:\nThe object itself.\nIf we did this.a(), output // 10\nCall/apply/bind methods: (Watch the video for call/apply/bind)\nCall is basically used for sharing the content of another object.\nHere's what's happening:\nWhen you use student.printName()\nthis points to whatever is before the dot (.)\nSo this refers to student object\nTherefore this.name prints \"John\"\nWhen you use student.printName.call(student2)\ncall method lets you borrow a function and use it with a different object\nIt says \"hey, use this function, but pretend this is student2\"\nSo now this refers to student2\nTherefore this.name prints \"Kalpit\"\nThink of call like borrowing a friend's method:\nstudent2 is borrowing the printName function from student\ncall lets you say \"use this function, but with my data instead\"\nThere's also apply and bind which work similarly:\nCODE:\nstudent.printName.apply(student2); // Same as call\nconst newFn = student.printName.bind(student2); // Creates new function\nnewFn(); // Prints: \"Kalpit\"\nBehaviour of this keyword inside arrow functions:\nArrow functions don't provide their own this binding.\nHere, in this code, the value of this will not be according to the function. It will be according to its \"enclosing lexical environment\". So here, the value is again a window object.\nNow,\nFor this piece of code. What will be the output?\nHere the output will be:\nThe object itself. Why?\nCheck its enclosing lexical environment. The enclosing lexical environment is the function in method x(). That is why, it is printing the object itself.\nIt will behave exactly like this code.\nBehaviour of this keyword inside DOM:\nIn this piece of code, the value of this will be the value of button element itself.\nSo if the question is: What is the value of this inside DOM?\nthis inside DOM elements => reference to HTMLElement.\nFlattening Objects"}